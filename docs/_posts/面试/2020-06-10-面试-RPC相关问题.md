---
title: RPC相关问题
categories:
- 面试
tags: [RPC]
---

* 目录
{:toc}


# 什么是 RPC ？

* RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。
* 除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。
* 其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。与Akka有区别，Akka是点对点，没有严格的客户端和服务端的区别，本质都是Actor对消息进行消费，而对RPC而言，一般都有明显的B/S风格（客户端/服务端）。

**简单的说**

* RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。
* RPC会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）。
* 客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。

# 为什么我们要用 RPC ？

RPC 的主要目标是让构建分布式应用更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。这里的透明机制与Actor模型提供的位置透明性有区别。[Actor的位置透明性说明](https://dreamylost.cn/akkaactor/AkkaActor-Actor%E7%9A%84%E4%BD%8D%E7%BD%AE%E9%80%8F%E6%98%8E%E6%80%A7%E8%AF%B4%E6%98%8E.html)

**RPC 需要解决的三个问题**

> RPC要达到的目标：远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

1. Call ID映射。我们怎么告诉远程机器我们要调用哪个函数呢？在本地调用中，函数体是直接通过函数指针（引用）来指定的，我们调用具体函数，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，是无法调用函数指针的，因为两个进程的地址空间是完全不一样。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个（函数 <--> Call ID}）映射表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
2. 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
3. 网络传输。远程调用往往是基于网络的，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。
   
# 实现高可用 RPC 框架需要考虑什么问题 ？

> 要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架

1. 既然系统采用分布式架构，那一个服务势必会有多个实例，要解决如何获取实例的问题。所以需要一个服务注册中心，比如在Dubbo中，就可以使用Zookeeper（我们使用Consul）作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用；
2. 如何选择实例呢？就要考虑负载均衡，例如dubbo提供了4种负载均衡策略；
3. 如果每次都去注册中心查询列表，效率很低，那么就要加缓存；
4. 客户端总不能每次调用完都等着服务端返回数据，所以就要支持异步调用；
5. 服务端的接口修改了，老的接口还有人在用，这就需要版本控制；
6. 服务端总不能每次接到请求都马上启动一个线程去处理，于是就需要线程池；
7. 可能还需要有会话和状态保持的功能。

# 工作中使用什么 RPC ？

gRPC - 是Google开发的高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。
本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。

# RPC 组件有哪些 ？

1. 客户端（Client） - 服务调用方（服务消费者）
2. 客户端存根（Client Stub） - 存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端
3. 服务端存根（Server Stub） - 接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理
4. 服务端（Server） - 服务的真正提供者

**具体调用过程**
 
1. 服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；
2. 客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；
3. 客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；
4. 服务端存根（server stub）收到消息后进行解码（反序列化操作）；
5. 服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；
6. 本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；
7. 服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；
8. 客户端存根（client stub）接收到消息，并进行解码（反序列化）；
9. 服务消费方得到最终结果。

而RPC框架的实现目标则是将上面的第2-8步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。

# RPC 使用了哪些关键技术 ？

* 动态代理

生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。

* 序列化和反序列化

在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。

序列化 - 把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。

反序列化 - 把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。

目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。

* NIO通信

出于并发性能的考虑，传统的阻塞式IO显然不太合适，因此我们需要异步的IO，即NIO。Java提供了NIO的解决方案，Java 7也提供了更优秀的NIO.2支持。可以选择Netty或者MINA来解决NIO数据传输的问题。

* 服务注册中心

可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题（注册中心）。